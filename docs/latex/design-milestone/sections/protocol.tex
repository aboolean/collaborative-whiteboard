\section{Server-Client Communication}

\subsection{Protocol}

\subsection{Interaction}

\subsubsection{New Connections}

The Whiteboard server will maintain a background thread that listens for new connections. Upon accepting a new socket, a new thread prompts the client for a username, and then instantiates a new User, which is then added to the ArrayList of all Users.

\subsubsection{Request Streams}

GUI: The GUI maintains two threads, one which listens for requests from the associated User, and another which contains a BlockingQueue containing requests to be sent to the User. Possible requests include creating a new Whiteboard, deleting a Whiteboard, selecting a different Whiteboard, or sending a Stroke.

User: Each User object holds the client-side socket. The User maintains two threads, one which listens for requests from either its MasterBoard or its GUI, and another which contains a BlockingQueue containing requests to be sent to the GUI. The request() method parses GUI requests and sends the appropriately formatted text protocol message to either the MasterBoard (when a Stroke is made) or the WhiteboardServer (for other User/Whiteboard requests).

MasterBoard: The MasterBoard maintains two threads, one which listens for requests from any of its associated Users, and another which contains a BlockingQueue containing requests to be sent to all of its associated Users. For example, the listening thread will accept a request to create a new Stroke to be added to its strokes ArrayList, and then send that updated ArrayList to all its Users.

WhiteboardServer: The WhiteboardServer is responsible for instantiating new Users with each new connection, and creating new MasterBoard objects in response to requests from Users. It maintains an InputStream to receive requests from the Users, but does not need an OutputStream.

%A connection made between the client and server will create a socket, and a new User instance will be created on a background thread. When a user makes a change to their open board, a message as specified by the protocol above will be queued and sent to the server. The server itself then adds incoming messages from all clients to its own output queue, in the order of reception (not necessarily the order that the commands were sent from the clients). From this queue, messages containing information about what strokes should be drawn on each Canvas are sent back to each client. (Note that a stroke drawn by a client will be repeated on that client's Canvas.) The order of the commands will be preserved for all clients because the server is sending them from an ordered queue.